# ============================================================================
# DEFAULT CONFIGURATION FOR MPS ALGORITHM
# ============================================================================
# Purpose: Base configuration for Matrix-Parametrized Proximal Splitting
# Algorithm: Based on arXiv:2503.13403v1 (Semidefinite Relaxation Based Localization)
# 
# RMSE INTERPRETATION:
#   - Algorithm reports NORMALIZED RMSE (dimensionless, as in papers)
#   - Normalized RMSE = error as fraction of communication radius
#   - Physical RMSE (meters) = normalized_rmse × communication_radius
#   - Communication radius (meters) = communication_range × scale
#   Example: With scale=100m and range=0.3:
#     - Communication radius = 30 meters
#     - Normalized RMSE of 0.15 = 15% of radius = 4.5 meters error
#
# Expected Performance:
#   - Runtime: 5-10 seconds for 30 sensors
#   - Normalized RMSE: 0.10-0.20 (10-20% of communication radius)
#   - Physical error depends on scale (see RMSE interpretation above)
# ============================================================================

# ----------------------------------------------------------------------------
# NETWORK CONFIGURATION
# Defines the sensor network topology and structure
# ----------------------------------------------------------------------------
network:
  # Number of sensor nodes to localize (unknown positions)
  # Typical values: 10-200 depending on application
  # Scaling: O(n²) complexity, doubling sensors ~4x runtime
  n_sensors: 30
  
  # Number of anchor nodes with known positions
  # Rule of thumb: Use 15-20% of n_sensors for good localization
  # Minimum: 3 for 2D (4 for 3D) to avoid ambiguity
  # More anchors = better accuracy but higher deployment cost
  n_anchors: 6
  
  # Spatial dimension of the network
  # 2: 2D localization (x,y) - most common for indoor/outdoor WSN
  # 3: 3D localization (x,y,z) - for UAVs, underwater, or 3D indoor
  dimension: 2
  
  # Maximum communication distance as fraction of network scale
  # Range: [0.1, 1.0] where 1.0 means all nodes can communicate
  # 0.3 = nodes communicate if distance < 0.3 (in unit coordinates)
  # Physical communication radius = communication_range × scale meters
  # Example: range=0.3, scale=100m → physical radius = 30m
  # Lower values: sparser network, harder localization, more realistic
  # Higher values: denser network, easier localization, less realistic
  # Affects average node degree: ~(π * range² * n_sensors) / area
  communication_range: 0.3
  
  # Network deployment area size in meters
  # Defines the physical scale of the network
  # Internally, positions are kept in [0,1] × [0,1] for numerical stability
  # This scale parameter maps unit square to physical dimensions
  # Example: scale=100 means 100m × 100m deployment area
  # RMSE interpretation: normalized_rmse × (communication_range × scale) = meters
  # With scale=100, range=0.3: RMSE of 0.15 = 15% of 30m = 4.5m error
  scale: 1.0
  
  # Network topology generation method
  # Options:
  #   "random": Uniform random placement (default, most general)
  #   "grid": Regular grid placement (structured, artificial)
  #   "cluster": Clustered placement (models real deployments)
  topology: "random"

# ----------------------------------------------------------------------------
# MEASUREMENT CONFIGURATION
# Defines how distance measurements are obtained and their characteristics
# ----------------------------------------------------------------------------
measurements:
  # Gaussian noise standard deviation as fraction of true distance
  # Range: [0.0, 0.5] where 0.0 = perfect measurements
  # 0.05 = 5% noise: measured = true * (1 + 0.05 * N(0,1))
  # Typical values:
  #   0.01-0.03: High-quality measurements (UWB, good conditions)
  #   0.03-0.10: Standard measurements (WiFi, normal conditions)
  #   0.10-0.30: Noisy measurements (acoustic, poor conditions)
  noise_factor: 0.05
  
  # Type of distance measurement technology
  # Options:
  #   "distance": Direct distance (TOA, TDOA, UWB)
  #   "rssi": Received Signal Strength (WiFi, Bluetooth)
  #   "toa": Time of Arrival (GPS, acoustic)
  #   "tdoa": Time Difference of Arrival (cellular)
  measurement_type: "distance"
  
  # Probability of gross outlier measurements
  # Range: [0.0, 0.3] where 0.0 = no outliers
  # Models non-line-of-sight, multipath, or hardware failures
  # Outliers are generated as: true_dist * uniform(0.5, 2.0)
  outlier_probability: 0.0
  
  # Enable carrier phase measurements for millimeter accuracy
  # Only applicable for RF-based ranging (GPS, UWB)
  # true: Adds carrier phase ambiguity resolution (complex, accurate)
  # false: Standard ranging only (simple, less accurate)
  carrier_phase: false
  
  # Random seed for reproducible experiments
  # Set to null for random initialization
  # Use same seed to compare algorithms on identical networks
  seed: 42

# ----------------------------------------------------------------------------
# MPS ALGORITHM CONFIGURATION
# Core parameters for Matrix-Parametrized Proximal Splitting
# ----------------------------------------------------------------------------
algorithm:
  # Algorithm variant name
  # Options:
  #   "mps": Standard MPS with ADMM inner solver
  #   "mps_sdp": MPS with SDP relaxation
  #   "distributed_mps": MPI-distributed version
  name: "mps"
  
  # Proximal gradient mixing parameter γ (gamma)
  # Range: (0, 1) - MUST be strictly between 0 and 1
  # Controls the weighted average in proximal updates:
  #   x^(k+1) = γ * prox(x^k) + (1-γ) * consensus(x^k)
  # Lower values (0.9-0.99): More emphasis on consensus, slower but stable
  # Higher values (0.99-0.999): More emphasis on proximal, faster but may oscillate
  # Paper recommendation: 0.999 for most problems
  gamma: 0.999
  
  # Step size / over-relaxation parameter α (alpha)
  # Range: (0, ∞) but typically [0.1, 50]
  # Controls the aggressiveness of updates:
  #   v^(k+1) = v^k + α * (x^(k+1) - x^k)
  # Small α (0.1-1.0): Conservative, stable, slow convergence
  # Medium α (1.0-10.0): Balanced speed and stability (recommended)
  # Large α (10.0-50.0): Aggressive, fast initial progress, may diverge
  # Auto-tuning: Set adaptive_alpha=true for automatic adjustment
  alpha: 10.0
  
  # Maximum number of outer iterations
  # Range: [100, 10000] depending on accuracy requirements
  # Each iteration involves:
  #   1. Proximal operator evaluation (ADMM inner solve)
  #   2. Consensus update (matrix multiplication)
  # Typical convergence: 200-500 iterations for 1e-6 tolerance
  max_iterations: 1000
  
  # Convergence tolerance for relative change in objective
  # Stops when: |f(k) - f(k-1)| / |f(k)| < tolerance
  # Range: [1e-8, 1e-3]
  #   1e-3: Quick and approximate
  #   1e-6: Standard accuracy (recommended)
  #   1e-8: High precision (slow)
  tolerance: 1e-6
  
  # Enable verbose output for debugging
  # true: Print iteration details (objective, errors, timing)
  # false: Minimal output (recommended for production)
  verbose: false
  
  # Early stopping based on objective function plateau
  # Stops if objective doesn't improve for N iterations
  # Prevents wasting computation on marginal improvements
  early_stopping: true
  
  # Number of iterations to check for plateau
  # If objective change < 0.1% for this many iterations, stop
  early_stopping_window: 100
  
  # Parallel evaluation of proximal operators (experimental)
  # true: Evaluate all sensor proximal problems in parallel
  # false: Sequential evaluation (required for L-matrix dependencies)
  # Only enable if L matrix is diagonal (rare)
  parallel_proximal: false
  
  # Use 2-block Sinkhorn-Knopp construction
  # true: Enhanced 2-block structure with zero diagonal (recommended)
  # false: Standard Sinkhorn-Knopp (may not satisfy constraints)
  # 2-block ensures W*1=0 constraint for consensus
  use_2block: true
  
  # Adaptive step size adjustment
  # true: Automatically adjust α based on progress
  # false: Fixed α throughout (more predictable)
  # Adaptive can help with difficult problems
  adaptive_alpha: false

# ----------------------------------------------------------------------------
# ADMM SOLVER CONFIGURATION
# Parameters for inner ADMM solver used in proximal operator evaluation
# ----------------------------------------------------------------------------
admm:
  # Maximum iterations for inner ADMM solver
  # Range: [10, 500]
  # Each proximal evaluation runs ADMM to solve:
  #   minimize ||S - X||² + λ*||X||_1 subject to X ⪰ 0
  # More iterations = more accurate proximal, but slower
  # Typical: 50-100 for standard problems
  iterations: 100
  
  # Convergence tolerance for ADMM
  # Range: [1e-8, 1e-3]
  # Can be looser than outer tolerance since it's an inner solve
  # Rule of thumb: Use same or 10x looser than algorithm.tolerance
  tolerance: 1e-6
  
  # ADMM penalty parameter ρ (rho)
  # Range: [0.01, 100]
  # Controls the penalty for constraint violation:
  #   L_ρ = f(x) + g(z) + y'(x-z) + (ρ/2)||x-z||²
  # Small ρ (0.01-0.1): Emphasize objective, slow constraint satisfaction
  # Medium ρ (0.5-2.0): Balanced (recommended)
  # Large ρ (5-100): Emphasize constraints, may lose objective accuracy
  rho: 1.0
  
  # Warm-start ADMM with previous solution
  # true: Initialize with solution from previous iteration (faster)
  # false: Cold start each time (more robust but slower)
  # Highly recommended to keep true
  warm_start: true

# ----------------------------------------------------------------------------
# MPI DISTRIBUTED EXECUTION CONFIGURATION
# Settings for parallel execution across multiple processes
# ----------------------------------------------------------------------------
mpi:
  # Enable MPI distributed execution
  # true: Use MPI for parallel computation (requires mpirun)
  # false: Single-process execution (default)
  enable: false
  
  # Asynchronous communication between processes
  # true: Non-blocking sends/receives (better performance)
  # false: Blocking communication (simpler, more predictable)
  async_communication: false
  
  # MPI communication buffer size in kilobytes
  # Range: [64, 16384] KB
  # Larger buffers reduce communication overhead but use more memory
  # Size needed: ~8 * n_sensors * max_neighbors * sizeof(double) / n_processes
  buffer_size_kb: 1024
  
  # Use collective MPI operations (AllReduce, Bcast)
  # true: Efficient tree-based collectives (recommended)
  # false: Point-to-point only (for debugging)
  collective_operations: true
  
  # Checkpoint interval for fault tolerance
  # Save state every N iterations (0 = disabled)
  # Useful for long runs on unreliable clusters
  checkpoint_interval: 100
  
  # Load balancing strategy for sensor distribution
  # Options:
  #   "block": Contiguous blocks of sensors per process (simple)
  #   "cyclic": Round-robin distribution (better balance)
  #   "dynamic": Runtime load balancing (adaptive but complex)
  load_balancing: "block"

# ----------------------------------------------------------------------------
# PERFORMANCE MONITORING CONFIGURATION
# Settings for tracking and analyzing algorithm performance
# ----------------------------------------------------------------------------
performance:
  # Track detailed performance metrics
  # true: Record objective, errors, timing per iteration
  # false: Minimal tracking (faster)
  track_metrics: true
  
  # Logging interval (iterations)
  # Print progress every N iterations (0 = disabled)
  # Lower values give more feedback but clutter output
  log_interval: 10
  
  # Save checkpoint files during execution
  # true: Save state periodically (allows restart)
  # false: No checkpoints (saves disk I/O)
  save_checkpoints: false

# ----------------------------------------------------------------------------
# OUTPUT CONFIGURATION
# Settings for saving results and visualization
# ----------------------------------------------------------------------------
output:
  # Save final results to file
  # true: Write JSON/NPY files with positions and metrics
  # false: No file output (for benchmarking)
  save_results: true
  
  # Output directory for results
  # Supports environment variables: ${HOME}/results/
  # Creates directory if it doesn't exist
  output_dir: "results/"
  
  # Save intermediate results every N iterations
  # 0 = only save final results
  # Useful for analyzing convergence behavior
  save_interval: 50
  
  # Save estimated sensor positions
  # true: Output positions as numpy array
  # false: Only save metrics (smaller files)
  save_positions: true
  
  # Save performance metrics (objective, errors, timing)
  # true: Full convergence history
  # false: Only final values
  save_metrics: true
  
  # Generate plots after completion
  # true: Create convergence plots, position plots in separate windows
  # false: No visualization (faster, headless operation)
  plot_results: true